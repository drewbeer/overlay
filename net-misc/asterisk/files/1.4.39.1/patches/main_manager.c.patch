--- asterisk-1.4.39.1/main/manager.c	2010-10-02 01:50:05.000000000 -0700
+++ asterisk-1.4.39.1-vici/main/manager.c	2012-05-16 19:10:51.000000000 -0700
@@ -224,6 +224,7 @@ struct mansession_session {
 	struct eventqent *eventq;
 	/* Timeout for ast_carefulwrite() */
 	int writetimeout;
+	int needclose;             /*!< Boolean, indicating that the client has closed, but we still have things to write */
 	int pending_event;         /*!< Pending events indicator in case when waiting_thread is NULL */
 	AST_LIST_ENTRY(mansession_session) list;
 };
@@ -2221,8 +2222,9 @@ static int process_events(struct mansess
 		if ((s->session->authenticated && (s->session->readperm & eqe->category) == eqe->category) &&
 				   ((s->session->send_events & eqe->category) == eqe->category)) {
 			if (s->fd > -1) {
-				if (!ret && ast_carefulwrite(s->fd, eqe->eventdata, strlen(eqe->eventdata), s->session->writetimeout) < 0)
-					ret = -1;
+				if (!ret && !s->session->needclose && ast_carefulwrite(s->fd, eqe->eventdata, strlen(eqe->eventdata), s->session->writetimeout) < 0) {
+					s->session->needclose = 1;
+				}
 			} else if (!s->session->outputstr && !(s->session->outputstr = ast_calloc(1, sizeof(*s->session->outputstr)))) 
 				ret = -1;
 			else 
@@ -2384,7 +2386,14 @@ static int get_input(struct mansession_s
 		s->waiting_thread = pthread_self();
 		ast_mutex_unlock(&s->__lock);
 
-		res = ast_poll(fds, 1, -1);
+		/* If the pipe is closed, read only those events still queued */
+		if (s->needclose) {
+			if ((res = poll(fds, 1, s->writetimeout)) == 0) {
+				res = -1;
+			}
+		} else {
+			res = poll(fds, 1, -1);
+		}
 
 		ast_mutex_lock(&s->__lock);
 		s->waiting_thread = AST_PTHREADT_NULL;
